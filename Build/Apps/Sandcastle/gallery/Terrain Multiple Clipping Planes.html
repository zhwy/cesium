<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <meta
      name="description"
      content="User-defined clipping planes applied to terrain."
    />
    <meta name="cesium-sandcastle-labels" content="Showcases" />
    <title>Cesium Demo</title>
    <script type="text/javascript" src="../Sandcastle-header.js"></script>
    <script
      type="text/javascript"
      src="../../../CesiumUnminified/Cesium.js"
      nomodule
    ></script>
    <script src="../../../CesiumUnminified/Cesium.js"></script>
    <script>window.CESIUM_BASE_URL = "../../../CesiumUnminified/";</script>
  </head>
  <body
    class="sandcastle-loading"
    data-sandcastle-bucket="bucket-requirejs.html"
  >
    <style>
      @import url(../templates/bucket.css);
      #toolbar {
        background: rgba(42, 42, 42, 0.8);
        padding: 4px;
        border-radius: 4px;
      }
      #toolbar input {
        vertical-align: middle;
        padding-top: 2px;
        padding-bottom: 2px;
      }
    </style>
    <div id="cesiumContainer" class="fullSize"></div>
    <div id="loadingOverlay"><h1>Loading...</h1></div>
    <div id="toolbar">
      <input
        type="checkbox"
        value="false"
        data-bind="checked: clippingPlanesVisible, valueUpdate: 'input'"
      />
      Show multiple clipping on the globe
      <input
        type="checkbox"
        value="false"
        data-bind="checked: edgeStylingEnabled, valueUpdate: 'input'"
      />
      Edge styling enabled
    </div>
    <script id="cesium_sandcastle_script">
      window.startup = async function (Cesium) {
        "use strict";
        //Sandcastle_Begin
        const viewer = new Cesium.Viewer("cesiumContainer");
        viewer.camera.setView({
          destination: new Cesium.Cartesian3(1.5e7, 0, 0),
        });

        viewer.scene.debugShowFramesPerSecond = true;

        const { globe } = viewer.scene;
        globe.depthTestAgainstTerrain = true;

        const multiCollections = new Cesium.MultiClippingPlaneCollection({
          collections: [
            generateClippingPlanesCollection([
              Cesium.Cartesian3.fromDegrees(-10, -5),
              Cesium.Cartesian3.fromDegrees(10, -5),
              Cesium.Cartesian3.fromDegrees(0, 10),
            ]),
            generateClippingPlanesCollection([
              Cesium.Cartesian3.fromDegrees(-10, 5),
              Cesium.Cartesian3.fromDegrees(0, -10),
              Cesium.Cartesian3.fromDegrees(10, 5),
            ]),
          ],
          modelMatrix: Cesium.Matrix4.IDENTITY,
          edgeWidth: 5,
          edgeColor: Cesium.Color.WHITE,
        });
        globe.multiClippingPlanes = multiCollections;

        const handler = new Cesium.ScreenSpaceEventHandler(viewer.scene.canvas);
        let positions = [];

        // left click to add points to a clipping planes collection
        handler.setInputAction(function (movement) {
          const worldPosition = viewer.scene.pickPosition(movement.position);
          if (Cesium.defined(worldPosition)) {
            positions.push(worldPosition);
          }
        }, Cesium.ScreenSpaceEventType.LEFT_CLICK);

        // right click to end a clipping planes collection
        handler.setInputAction(function (movement) {
          const worldPosition = viewer.scene.pickPosition(movement.position);
          if (Cesium.defined(worldPosition)) {
            positions.push(worldPosition);
            if (positions.length > 2) {
              const collection = generateClippingPlanesCollection(positions);
              multiCollections.add(collection);
              positions = [];
            }
          }
        }, Cesium.ScreenSpaceEventType.RIGHT_CLICK);

        function generateClippingPlanesCollection(points) {
          const pointsLength = points.length;
          const clippingPlanes = [];
          for (let i = 0; i < pointsLength; ++i) {
            const nextIndex = (i + 1) % pointsLength;
            let midpoint = Cesium.Cartesian3.add(
              points[i],
              points[nextIndex],
              new Cesium.Cartesian3()
            );
            midpoint = Cesium.Cartesian3.multiplyByScalar(
              midpoint,
              0.5,
              midpoint
            );

            const up = Cesium.Cartesian3.normalize(
              midpoint,
              new Cesium.Cartesian3()
            );
            let right = Cesium.Cartesian3.subtract(
              points[nextIndex],
              midpoint,
              new Cesium.Cartesian3()
            );
            right = Cesium.Cartesian3.normalize(right, right);

            let normal = Cesium.Cartesian3.cross(
              right,
              up,
              new Cesium.Cartesian3()
            );
            normal = Cesium.Cartesian3.normalize(normal, normal);

            // Compute distance by pretending the plane is at the origin
            const originCenteredPlane = new Cesium.Plane(normal, 0.0);
            const distance = Cesium.Plane.getPointDistance(
              originCenteredPlane,
              midpoint
            );

            clippingPlanes.push(new Cesium.ClippingPlane(normal, distance));
          }

          return new Cesium.ClippingPlaneCollection({
            planes: clippingPlanes,
            modelMatrix: Cesium.Matrix4.IDENTITY,
          });
        }

        const viewModel = {
          clippingPlanesVisible: true,
          edgeStylingEnabled: true,
        };
        const toolbar = document.getElementById("toolbar");
        Cesium.knockout.track(viewModel);
        Cesium.knockout.applyBindings(viewModel, toolbar);

        // For tracking state when switching exampleTypes
        let clippingPlanesVisible = true;
        let edgeStylingEnabled = true;

        Cesium.knockout
          .getObservable(viewModel, "clippingPlanesVisible")
          .subscribe(function (value) {
            clippingPlanesVisible = value;
            globe.multiClippingPlanes = clippingPlanesVisible
              ? multiCollections
              : undefined;
          });

        Cesium.knockout
          .getObservable(viewModel, "edgeStylingEnabled")
          .subscribe(function (value) {
            edgeStylingEnabled = value;
            globe.multiClippingPlanes.edgeWidth = edgeStylingEnabled
              ? 5.0
              : 0.0;
          });

        //Sandcastle_End
      };
      if (typeof Cesium !== "undefined") {
        window.startupCalled = true;
        window.startup(Cesium).catch((error) => {
          "use strict";
          console.error(error);
        });
        Sandcastle.finishedLoading();
      }
    </script>
  </body>
</html>
