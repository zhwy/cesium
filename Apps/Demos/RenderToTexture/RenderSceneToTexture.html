<!doctype html>
<html lang="en">
  <head>
    <!-- Use correct character set. -->
    <meta charset="utf-8" />
    <!-- Tell IE to use the latest, best version. -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <!-- Make the application on mobile take up the full browser screen and disable user scaling. -->
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <title>Render Scene To Texture</title>
    <style>
      @import url(../../../../Build/CesiumUnminified/Widgets/widgets.css);

      html,
      body,
      #cesiumContainer {
        width: 100%;
        height: 100%;
        margin: 0;
        padding: 0;
        overflow: hidden;
      }

      button {
        position: absolute;
        z-index: 99;
      }
    </style>
  </head>

  <body>
    <div id="cesiumContainer"></div>
    <script type="module">
      // import IndexedDbCache from "../Lib/indexDbCache.js";
      import * as Cesium from "../../../../Build/CesiumUnminified/index.js";
      window.CESIUM_BASE_URL = "../../../../Build/CesiumUnminified/";
      window.Cesium = Cesium;
      Cesium.Ion.defaultAccessToken =
        "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiI0MjM4NGQ4Yi05MjAzLTQ3NzMtOTZmYS05ZDE1ZWZhYTk3OWMiLCJpZCI6MTEzNTYsInNjb3BlcyI6WyJhc3IiLCJnYyJdLCJpYXQiOjE1NTg2ODcwMDJ9.I0-TpqepRcWIVUUI8KrhoSZp-a70sRSRveNLBXOwOto";

      const WIDTH = 1024;

      class Reflector {
        constructor(viewer) {
          this.viewer = viewer;
          this.scene = viewer.scene;
          this.camera = viewer.camera;

          this.camera2 = new Cesium.Camera(viewer.scene);
          this.view2 = new Cesium.View(
            viewer.scene,
            this.camera2,
            viewer.scene._defaultView.viewport,
          );

          this.originView = viewer.scene._defaultView;

          this.drawRenderState = Cesium.RenderState.fromCache({
            depthTest: {
              enabled: false,
            },
          });
          this.texureRenderState = Cesium.RenderState.fromCache({
            depthTest: {
              enabled: false,
            },
            viewport: {
              x: 0,
              y: 0,
              width: WIDTH,
              height: WIDTH,
            },
          });

          this.outputTexture = undefined;
          this.framebuffer = undefined;
          this.clearCommand = undefined;
          this.drawCommand = undefined;
          this.textureCommand = undefined;
          this.initialized = false;

          this._initialize(viewer.scene.context);
        }
        _initialize(context) {
          this.outputTexture = new Cesium.Texture({
            width: WIDTH,
            height: WIDTH,
            context,
            pixelFormat: Cesium.PixelFormat.RGBA,
            pixelDatatype: Cesium.PixelDatatype.UNSIGNED_BYTE,
            flipX: false,
            flipY: false,
            // source: {
            //   width: 2,
            //   height: 1,
            //   arrayBufferView: textureTypedArray,
            // },
          });

          this.framebuffer = new Cesium.Framebuffer({
            context,
            colorTextures: [this.outputTexture],
          });

          this.view2.passState.framebuffer = this.framebuffer;

          this.clearCommand = new Cesium.ClearCommand({
            color: new Cesium.Color(0.0, 0.0, 0.0, 0.0),
            framebuffer: this.framebuffer,
            renderState: this.texureRenderState,
            pass: Cesium.Pass.OPAQUE,
          });

          this.drawCommand = this._createDrawCommands(context);

          this.scene.postUpdate.addEventListener((scene, time) => {});

          const center = Cesium.Cartesian3.fromDegrees(0.25, 0.25, 0);

          this.scene.postRender.addEventListener((scene, time) => {
            const normal = Cesium.Cartesian3.normalize(
              center,
              new Cesium.Cartesian3(),
            );

            const length = Cesium.Cartesian3.magnitude(
              Cesium.Cartesian3.subtract(
                center,
                this.camera.position,
                new Cesium.Cartesian3(),
              ),
            );
            // console.log(length);

            const dotProduct = Cesium.Cartesian3.dot(
              this.camera.direction,
              normal,
            );
            const scaledNormal = Cesium.Cartesian3.multiplyByScalar(
              normal,
              2.0 * dotProduct,
              new Cesium.Cartesian3(),
            );
            const reflection = Cesium.Cartesian3.subtract(
              this.camera.direction,
              scaledNormal,
              new Cesium.Cartesian3(),
            );

            const reflectorPosition = Cesium.Cartesian3.subtract(
              center,
              Cesium.Cartesian3.multiplyByScalar(
                reflection,
                length * 2,
                new Cesium.Cartesian3(),
              ),
              new Cesium.Cartesian3(),
            );

            this.camera2.position = reflectorPosition;
            this.camera2.direction = reflection;
            const right = Cesium.Cartesian3.cross(
              reflection,
              Cesium.Cartesian3.UNIT_Z,
              new Cesium.Cartesian3(),
            );
            const up = Cesium.Cartesian3.cross(
              right,
              reflection,
              new Cesium.Cartesian3(),
            );
            this.camera2.up = Cesium.Cartesian3.normalize(up, up);

            if (scene._defaultView !== this.view2) {
              // this.camera2.up = this.camera.up.clone();
              // this.camera2.direction = this.camera.direction.clone();
              // this.camera2.position = this.camera.position.clone();
              scene._defaultView = this.view2;
              scene.camera = this.camera2;
              const passState = this.view2.passState;

              if (scene.globe) {
                scene.globe.beginFrame(scene._frameState);
              }
              scene.updateEnvironment();
              scene.updateAndExecuteCommands(
                passState,
                new Cesium.Color(0.0, 0.0, 0.0, 0.0),
              );
              scene.resolveFramebuffers(passState);

              scene.context.uniformState.updatePass(Cesium.Pass.OVERLAY);
              const commandList = scene._overlayCommandList;
              try {
                for (let i = 0; i < commandList.length; ++i) {
                  commandList[i].execute(scene.context, passState);
                }
                // if (scene.globe) {
                //   scene.globe.endFrame(scene._frameState);

                //   if (!scene.globe.tilesLoaded) {
                //     scene._renderRequested = true;
                //   }
                // }

                // scene.context.endFrame();
              } catch (e) {
                console.log(e);
              }

              scene._defaultView = this.originView;
              scene.camera = this.camera;
              // this.clearCommand.execute(scene.context, this.view2.passState);
              this.drawCommand.execute(
                scene.context,
                this.originView.passState,
              );
            }
          });

          this.initialized = true;
        }
        _createDrawCommands(context) {
          const drawGeometry = new Cesium.Geometry({
            attributes: {
              position: new Cesium.GeometryAttribute({
                componentDatatype: Cesium.ComponentDatatype.DOUBLE,
                componentsPerAttribute: 3,
                values: new Float64Array([0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0]),
              }),
              st: new Cesium.GeometryAttribute({
                componentDatatype: Cesium.ComponentDatatype.FLOAT,
                componentsPerAttribute: 2,
                values: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
              }),
            },
            indices: new Uint16Array([0, 1, 2, 0, 2, 3]),
          });

          const attributeLocations =
            Cesium.GeometryPipeline.createAttributeLocations(drawGeometry);

          const shaderProgram = Cesium.ShaderProgram.fromCache({
            context,
            attributeLocations,
            vertexShaderSource: `
              in vec3 position;
              in vec2 st;

              out vec2 v_texCoord;

              void main() {
                gl_Position = vec4(position, 1.);
                v_texCoord = st;
              }
            `,
            fragmentShaderSource: `
              uniform sampler2D inputTexture;
              in vec2 v_texCoord;

              void main() {
                out_FragColor = texture(inputTexture, v_texCoord * (czm_viewport.zw / czm_viewport.ww));
              }
            `,
          });

          const scope = this;

          const drawCommand = new Cesium.DrawCommand({
            modelMatrix: Cesium.Matrix4.IDENTITY,
            pass: Cesium.Pass.TRANSLUCENT,
            shaderProgram: shaderProgram,
            renderState: this.drawRenderState,
            vertexArray: Cesium.VertexArray.fromGeometry({
              context,
              geometry: drawGeometry,
              attributeLocations,
              bufferUsage: Cesium.BufferUsage.STATIC_DRAW,
            }),
            primitiveType: Cesium.PrimitiveType.TRIANGLES,
            uniformMap: {
              inputTexture() {
                return scope.outputTexture;
              },
            },
          });

          drawCommand.name = "draw";

          return drawCommand;
        }
      }

      const viewer = new Cesium.Viewer("cesiumContainer", {
        neargroundSkyBox: false,
      });
      window._viewer = viewer;

      const polygon = new Cesium.PolygonGeometry({
        // height: 10000,
        polygonHierarchy: new Cesium.PolygonHierarchy(
          Cesium.Cartesian3.fromDegreesArrayHeights([
            0, 0, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0.5, 0,
          ]),
        ),
      });

      const test = viewer.scene.primitives.add(
        new Cesium.Primitive({
          geometryInstances: new Cesium.GeometryInstance({
            geometry: polygon,
          }),
          appearance: new Cesium.MaterialAppearance({
            material: new Cesium.Material({
              fabric: {
                type: "Color",
                uniforms: {
                  color: new Cesium.Color(1.0, 1.0, 0.0, 1),
                },
              },
            }),
          }),
        }),
      );
      test.name = "test";

      // const primitive = new CustomPrimitive();

      // viewer.scene.primitives.add(primitive);

      viewer.camera.setView({
        destination: Cesium.Cartesian3.fromDegrees(0, 0, 557000),
        orientation: {
          heading: 0,
          pitch: Cesium.Math.toRadians(-90),
          roll: 0,
        },
      });

      const reflector = new Reflector(viewer);
      reflector.initialized = true;
    </script>
  </body>
</html>
