<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>水面效果</title>
    <style>
      @import url(../../../../Build/CesiumUnminified/Widgets/widgets.css);
      body {
        padding: 0;
        margin: 0;
      }
      #cesiumContainer {
        width: 100vw;
        height: 100vh;
      }
    </style>
  </head>

  <body>
    <script src="../../Lib/dat.gui.min.js"></script>
    <div id="cesiumContainer"></div>
    <script type="module">
      import * as Cesium from "../../../../Build/CesiumUnminified/index.js";
      import Water from "./Water.js";

      const dat = window.dat;

      Cesium.Ion.defaultAccessToken =
        "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiI0MjM4NGQ4Yi05MjAzLTQ3NzMtOTZmYS05ZDE1ZWZhYTk3OWMiLCJpZCI6MTEzNTYsInNjb3BlcyI6WyJhc3IiLCJnYyJdLCJpYXQiOjE1NTg2ODcwMDJ9.I0-TpqepRcWIVUUI8KrhoSZp-a70sRSRveNLBXOwOto"; //设置你的ion加载Cesium资产

      function createSquareRectangle(centerLon, centerLat, sideLength) {
        // 将边长转换为度
        const earthRadius = 6371000; // 地球平均半径，单位：米
        const angularDistance = (sideLength / earthRadius) * (180 / Math.PI);

        // 计算经度差
        const lonDiff = angularDistance / Math.cos((centerLat * Math.PI) / 180);

        // 计算矩形的边界
        const west = centerLon - lonDiff / 2;
        const east = centerLon + lonDiff / 2;
        const south = centerLat - angularDistance / 2;
        const north = centerLat + angularDistance / 2;

        // 返回[west, south, east, north]格式的数组
        return [west, south, east, north];
      }

      async function main() {
        const viewer = new Cesium.Viewer("cesiumContainer", {
          nearGroundSkyBox: false,
          shadows: true,
          terrainShadows: Cesium.ShadowMode.ENABLED,
          terrainProvider: await Cesium.CesiumTerrainProvider.fromIonAssetId(
            1,
            {
              requestVertexNormals: true,
            },
          ),
        });

        // viewer.scene.sun.show = true;
        viewer.scene.msaaSamples = 4;
        viewer.scene.highDynamicRange = true;
        viewer.postProcessStages.fxaa.enabled = true;
        viewer.scene.globe.depthTestAgainstTerrain = false;
        viewer.scene.debugShowFramesPerSecond = true;
        const center = [-119.5509508318, 37.7379837881];
        const extent = createSquareRectangle(...center, 20000);
        console.log(extent);
        const rectangle = Cesium.Rectangle.fromDegrees(...extent);
        viewer.camera.flyTo({
          destination: rectangle,
          duration: 1.0,
        });
        window.viewer = viewer;

        const polygon = new Cesium.PolygonHierarchy(
          Cesium.Cartesian3.fromDegreesArray([
            extent[0],
            extent[1],
            extent[2],
            extent[1],
            extent[2],
            extent[3],
            extent[0],
            extent[3],
            extent[0],
            extent[1],
          ]),
        );

        const test = new Water({
          viewer,
          extent,
          polygon,
          minElevation: 1153.0408311859962,
          maxElevation: 3158.762303474051,
          heightMapUrl: "../Erosion/1724136544296.png",
          noiseMapUrl: "../waterNormals.jpg",
        });

        const gui = new dat.GUI();
        gui.add(test, "frequency", 1, 10000);
        gui.add(test, "amplitude", 0, 100);
        gui.add(test, "waterLevel", 0, 1);
        gui.add(test, "showLines");
        gui.add(test, "sunDirectionX", 0, 1);
        gui.add(test, "sunDirectionY", 0, 1);
        gui.add(test, "sunDirectionZ", 0, 1);

        viewer.scene.primitives.add(test);
      }

      main();
    </script>
  </body>
</html>
