<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>后处理球</title>
    <style>
      @import url(../../../Build/CesiumUnminified/Widgets/widgets.css);
      body {
        padding: 0;
        margin: 0;
      }
      #cesiumContainer {
        width: 100vw;
        height: 100vh;
      }
    </style>
  </head>

  <body>
    <div id="cesiumContainer"></div>
    <script type="module">
      import * as Cesium from "../../../Build/CesiumUnminified/index.js";
      Cesium.Ion.defaultAccessToken =
        "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiI0MjM4NGQ4Yi05MjAzLTQ3NzMtOTZmYS05ZDE1ZWZhYTk3OWMiLCJpZCI6MTEzNTYsInNjb3BlcyI6WyJhc3IiLCJnYyJdLCJpYXQiOjE1NTg2ODcwMDJ9.I0-TpqepRcWIVUUI8KrhoSZp-a70sRSRveNLBXOwOto"; //设置你的ion加载Cesium资产

      const viewer = new Cesium.Viewer("cesiumContainer", {
        nearGroundSkyBox: false,
        shadows: false,
      });

      const scene = viewer.scene;
      scene.globe.depthTestAgainstTerrain = true;

      viewer.camera.flyTo({
        destination: Cesium.Cartesian3.fromDegrees(120, 30, 1500),
        orientation: {
          heading: Cesium.Math.toRadians(0),
          pitch: Cesium.Math.toRadians(-45),
          roll: 0,
        },
        duration: 0,
      });

      window.viewer = viewer;

      const point = viewer.entities.add({
        position: Cesium.Cartesian3.fromDegrees(120, 30, 10),
        point: {
          pixelSize: 5,
          color: Cesium.Color.BLUE,
        },
      });

      let stage;
      const processTerrainProvider = () => {
        if (stage) {
          scene.postProcessStages.remove(stage);
        }

        const originRequest = viewer.terrainProvider.requestTileGeometry;

        let stageLoading = false;
        const loadStage = () => {
          if (stageLoading) {
            return;
          }
          stageLoading = true;
          setTimeout(() => {
            stage = new Cesium.PostProcessStage({
              id: "test",
              uniforms: {
                center() {
                  return point.position.getValue();
                },
              },
              fragmentShader: /* glsl */ `
                uniform sampler2D colorTexture;
                uniform sampler2D depthTexture;
                uniform vec3 center;

                in vec2 v_textureCoordinates;

                float getDepth(vec2 uv) {
                  return czm_unpackDepth(texture(czm_globeDepthTexture, uv));
                }

                vec3 getEyeCoordinate(vec2 fragCoord, float depth) {
                  vec4 eyeCoordinate4 = czm_windowToEyeCoordinates(fragCoord, depth);
                  return eyeCoordinate4.xyz / eyeCoordinate4.w;
                }

                struct IntersectInfo {
                  bool intersected;
                  vec3 pos;
                };

                // 点是否与球相交
                IntersectInfo isIntersectSphere(vec3 center, float radius, vec3 rayOrigin, vec3 rayDirection, vec3 point) {
                  IntersectInfo intersectInfo;
                  intersectInfo.intersected = false;
                  intersectInfo.pos = vec3(0.);

                  vec3 o2c = normalize(center - rayOrigin);
                  float o2cDistance = length(center - rayOrigin);
                  float d = o2cDistance * dot(o2c, rayDirection);
                  float h = sqrt(o2cDistance * o2cDistance - d * d);
                  float halfDis = sqrt(radius * radius - h * h);
                  float minDistance = d - halfDis;
                  // float maxDistance = d + halfDis;

                  float distance = length(point - rayOrigin);
                  intersectInfo.intersected = distance >= minDistance;
                  intersectInfo.pos = rayOrigin + minDistance * rayDirection;

                  return intersectInfo;
                }

                void main() {
                  out_FragColor = texture(colorTexture, v_textureCoordinates);

                  // vec3 centerEyeCoordinate = getEyeCoordinate(vec2(0.5, 0.5));
                  vec4 centerEyeCoordinate = czm_view * vec4(center, 1.);

                  float depth = getDepth(v_textureCoordinates);
                  if (depth == 0.) depth = 1.; // 天空深度调整

                  vec3 pointEC = getEyeCoordinate(gl_FragCoord.xy, depth);

                  // if (length(centerEyeCoordinate.xyz / centerEyeCoordinate.w - pointEC) < 20.) {
                  //   out_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
                  // }
                  // out_FragColor = vec4(pointEC.x, pointEC.y, 1., pointEC.z);

                  vec3 rayOrigin = vec3(0.);
                  vec3 rayDirection = normalize(pointEC);

                  IntersectInfo intersectInfo = isIntersectSphere(centerEyeCoordinate.xyz / centerEyeCoordinate.w, 1000., rayOrigin, rayDirection, pointEC);
                  if (intersectInfo.intersected) {
                    vec3 normalEC = normalize(intersectInfo.pos - centerEyeCoordinate.xyz / centerEyeCoordinate.w);
                    vec3 color = vec3(1.0, 0.0, 0.0);
                    vec3 lightDirEC = czm_lightDirectionEC;
                    float density = dot(normalEC, lightDirEC);
                    out_FragColor = vec4(color * density + vec3(0.1), 1.0);
                  }

                }
          `,
            });
            scene.postProcessStages.add(stage);
          }, 5000);
        };

        viewer.terrainProvider.requestTileGeometry = (x, y, level, request) =>
          new Promise((resolve, reject) => {
            loadStage();
            originRequest(x, y, level, request).then((geometry) => {
              resolve(geometry);
            }, reject);
          });
      };

      processTerrainProvider();

      // 地形变化时depthTexture会暂时取不到值
      scene.globe.terrainProviderChanged.addEventListener(() => {
        processTerrainProvider();
      });
    </script>
  </body>
</html>
