<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>后处理高度雾</title>
    <style>
      @import url(../../../Build/CesiumUnminified/Widgets/widgets.css);
      body {
        padding: 0;
        margin: 0;
      }
      #cesiumContainer {
        width: 100vw;
        height: 100vh;
      }
    </style>
  </head>

  <body>
    <div id="cesiumContainer"></div>
    <script type="module">
      import * as Cesium from "../../../Build/CesiumUnminified/index.js";
      Cesium.Ion.defaultAccessToken =
        "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiI4MDRmNjJiNS1iNmVhLTQwMDEtOWM0ZS02MTdlNWZiZmIwYjciLCJpZCI6MTEzNTYsImlhdCI6MTc0MTc4ODkyNX0.lrveOeXTCbdSofQPBpkwlC-rTJBFL9nZ1x1DI-DDKHk"; //设置你的ion加载Cesium资产

      const viewer = new Cesium.Viewer("cesiumContainer", {
        nearGroundSkyBox: false,
        shadows: false,
      });

      Cesium.createWorldTerrainAsync().then((terrainProvider) => {
        viewer.terrainProvider = terrainProvider;
      });

      const scene = viewer.scene;
      scene.globe.depthTestAgainstTerrain = true;

      viewer.screenSpaceEventHandler.setInputAction(function onLeftClick(
        movement,
      ) {
        const worldPosition = viewer.scene.pickPosition(movement.position);
        const cartographic = Cesium.Cartographic.fromCartesian(worldPosition);
        console.log(cartographic);
      }, Cesium.ScreenSpaceEventType.LEFT_CLICK);

      viewer.camera.flyTo({
        destination: Cesium.Cartesian3.fromDegrees(120, 30, 1500),
        orientation: {
          heading: Cesium.Math.toRadians(0),
          pitch: Cesium.Math.toRadians(-45),
          roll: 0,
        },
        duration: 0,
      });

      window.viewer = viewer;

      const stage = new Cesium.PostProcessStage({
        id: "fog",
        uniforms: {
          earthRadius() {
            const carto = viewer.camera.positionCartographic;
            const surfacePoint = Cesium.Cartesian3.fromRadians(
              carto.longitude,
              carto.latitude,
              0,
            );
            return Cesium.Cartesian3.magnitude(surfacePoint);
          },
          fogHeight() {
            return 100;
          },
          maxAlpha() {
            return 0.8;
          },
          fotNearFar() {
            return new Cesium.Cartesian4(2000, 0, 20000, 1.0);
          },
        },
        fragmentShader: /* glsl */ `
          #define METHOD 3

          uniform sampler2D colorTexture;
          uniform sampler2D depthTexture;
          uniform float earthRadius;
          uniform float fogHeight;
          uniform float maxAlpha;
          uniform vec4 fotNearFar;

          in vec2 v_textureCoordinates;

          float getDepth(vec2 uv) {
            return czm_unpackDepth(texture(depthTexture, uv));
          }

          vec3 getEyeCoordinate(vec2 fragCoord, float depth) {
            vec4 eyeCoordinate4 = czm_windowToEyeCoordinates(fragCoord, depth);
            return eyeCoordinate4.xyz / eyeCoordinate4.w;
          }

          vec3 getWorldCoordinateFromEye(vec3 eyeCoord) {
            vec4 worldCoordinate4 = czm_inverseView * vec4(eyeCoord, 1.);
            return worldCoordinate4.xyz / worldCoordinate4.w;
          }

          float simpleLinearHeightFog(float pixelHeight) {
            float fog = clamp(1.0 - pixelHeight / fogHeight, 0.0, maxAlpha);
            return fog;
          }

          float simpleLinearDistanceFog(vec3 eyeCoord) {
            float startDistance = fotNearFar.x;
              float startValue = fotNearFar.y;
              float endDistance = fotNearFar.z;
              float endValue = fotNearFar.w;
              float dis = length(eyeCoord);
              float disRate = clamp((dis - startDistance) / (endDistance - startDistance), 0.0, 1.0);
              float fog = mix(startValue, endValue, disRate);

              return fog;
          }

          void main() {
            out_FragColor = texture(colorTexture, v_textureCoordinates);

            float depth = getDepth(v_textureCoordinates);
            if (depth == 0.) depth = 1.; // 天空深度调整

            vec3 targetEC = getEyeCoordinate(gl_FragCoord.xy, depth);

            #if METHOD == 1
              vec3 targetWC = getWorldCoordinateFromEye(targetEC);
              float pixelHeight = length(targetWC) - earthRadius;
              float fog = simpleLinearHeightFog(pixelHeight);
              out_FragColor = mix(out_FragColor, vec4(1.0), fog);
              return;
            #elif METHOD == 2
              float fog = simpleLinearDistanceFog(targetEC);
              out_FragColor = mix(out_FragColor, vec4(1.0), fog);
              return;
            #endif

            vec3 dir = normalize(targetEC);

            float marchDistance = length(targetEC);
            int marchCount = 32;
            float marchStep = marchDistance / float(marchCount);
            vec3 point = vec3(0.);

            float densitySum = 0.;
            for(int i = 0; i < marchCount; i++) {
              point += dir * marchStep;

              vec3 pointWC = getWorldCoordinateFromEye(point);
              float currentHeight = length(pointWC) - earthRadius;
              densitySum += simpleLinearHeightFog(currentHeight) * 0.05;

              if (densitySum > 0.95) {
                break;
              }
            }

            out_FragColor.rgb = vec3(out_FragColor.rgb * (1.0 - densitySum) + vec3(densitySum));
          }
        `,
      });
      scene.postProcessStages.add(stage);
    </script>
  </body>
</html>
