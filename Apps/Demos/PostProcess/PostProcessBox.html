<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>后处理盒</title>
    <style>
      @import url(../../../Build/CesiumUnminified/Widgets/widgets.css);
      body {
        padding: 0;
        margin: 0;
      }
      #cesiumContainer {
        width: 100vw;
        height: 100vh;
      }
    </style>
  </head>

  <body>
    <div id="cesiumContainer"></div>
    <script type="module">
      import * as Cesium from "../../../Build/CesiumUnminified/index.js";
      Cesium.Ion.defaultAccessToken =
        "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiI0MjM4NGQ4Yi05MjAzLTQ3NzMtOTZmYS05ZDE1ZWZhYTk3OWMiLCJpZCI6MTEzNTYsInNjb3BlcyI6WyJhc3IiLCJnYyJdLCJpYXQiOjE1NTg2ODcwMDJ9.I0-TpqepRcWIVUUI8KrhoSZp-a70sRSRveNLBXOwOto"; //设置你的ion加载Cesium资产

      const viewer = new Cesium.Viewer("cesiumContainer", {
        nearGroundSkyBox: false,
        shadows: false,
      });

      const scene = viewer.scene;
      scene.globe.depthTestAgainstTerrain = true;

      viewer.camera.flyTo({
        destination: Cesium.Cartesian3.fromDegrees(120, 30, 1500),
        orientation: {
          heading: Cesium.Math.toRadians(0),
          pitch: Cesium.Math.toRadians(-45),
          roll: 0,
        },
        duration: 0,
      });

      window.viewer = viewer;

      const point1 = viewer.entities.add({
        position: Cesium.Cartesian3.fromDegrees(120, 30, 100),
        point: {
          pixelSize: 5,
          color: Cesium.Color.BLUE,
        },
      });

      const point2 = viewer.entities.add({
        position: Cesium.Cartesian3.fromDegrees(120.01, 30.01, 200),
        point: {
          pixelSize: 5,
          color: Cesium.Color.BLUE,
        },
      });

      let stage;
      const processTerrainProvider = () => {
        if (stage) {
          scene.postProcessStages.remove(stage);
        }

        const originRequest = viewer.terrainProvider.requestTileGeometry;

        let stageLoading = false;
        const loadStage = () => {
          if (stageLoading) {
            return;
          }
          stageLoading = true;
          setTimeout(() => {
            stage = new Cesium.PostProcessStage({
              id: "test",
              uniforms: {
                point1() {
                  return point1.position.getValue();
                },
                point2() {
                  return point2.position.getValue();
                },
              },
              fragmentShader: /* glsl */ `
                uniform sampler2D colorTexture;
                uniform sampler2D depthTexture;
                uniform vec3 point1;
                uniform vec3 point2;

                in vec2 v_textureCoordinates;

                float getDepth(vec2 uv) {
                  return czm_unpackDepth(texture(czm_globeDepthTexture, uv));
                }

                vec3 getEyeCoordinate(vec2 fragCoord, float depth) {
                  vec4 eyeCoordinate4 = czm_windowToEyeCoordinates(fragCoord, depth);
                  return eyeCoordinate4.xyz / eyeCoordinate4.w;
                }

                struct OBB {
                  vec3 center;      // 中心点
                  vec3 halfExtents; // 半长度
                  mat3 rotation;    // 旋转矩阵
                };

                // 从两个点计算OBB (简化版本)
                OBB createOBBFromPoints(vec3 p1, vec3 p2) {
                  OBB obb;

                  // 计算中心点
                  obb.center = (p1 + p2) * 0.5;

                  // 盒子尺寸
                  vec3 dimensions = abs(p2 - p1);
                  obb.halfExtents = dimensions * 0.5;

                  // 计算主要方向
                  vec3 dir = normalize(p2 - p1);

                  // 找到垂直于dir的两个方向来构建完整的旋转矩阵
                  vec3 up = abs(dir.y) < 0.999 ? vec3(0, 1, 0) : vec3(1, 0, 0);
                  vec3 right = normalize(cross(up, dir));
                  up = normalize(cross(dir, right));

                  // 构建旋转矩阵
                  obb.rotation = mat3(right, up, dir);

                  return obb;
                }

                struct IntersectInfo {
                  bool hit;
                  float tNear;
                  float tFar;
                };

                IntersectInfo isIntersect(AABB box, vec3 rayOrigin, vec3 rayDirection, vec3 point) {
                  IntersectInfo result;
                  result.hit = false;

                  // 避免除以零
                  rayDirection = normalize(rayDirection);
                  vec3 dirInv = 1.0 / rayDirection;

                  // 计算与各轴对齐平面的交点
                  vec3 t1 = (box.min - rayOrigin) * dirInv;
                  vec3 t2 = (box.max - rayOrigin) * dirInv;

                  // 获取进入点和离开点的t值
                  vec3 tMin = min(t1, t2);
                  vec3 tMax = max(t1, t2);

                  // 找到最大的进入t和最小的离开t
                  float tNear = max(max(tMin.x, tMin.y), tMin.z);
                  float tFar = min(min(tMax.x, tMax.y), tMax.z);

                  // 判断是否相交
                  if (tNear <= tFar && tFar > 0.0) {
                    result.hit = length(point - rayOrigin) >= tNear;
                    result.tNear = tNear;
                    result.tFar = tFar;
                  }

                  return result;
                }

                void main() {
                  out_FragColor = texture(colorTexture, v_textureCoordinates);

                  vec4 point1EC = czm_view * vec4(point1, 1.);
                  vec4 point2EC = czm_view * vec4(point2, 1.);
                  vec3 minPos = min(point1EC.xyz / point1EC.w, point2EC.xyz / point2EC.w);
                  vec3 maxPos = max(point1EC.xyz / point1EC.w, point2EC.xyz / point2EC.w);
                  AABB box = AABB(minPos, maxPos);

                  float depth = getDepth(v_textureCoordinates);
                  if (depth == 0.) depth = 1.; // 天空深度调整

                  // 像素点的视口坐标
                  vec3 pointEC = getEyeCoordinate(gl_FragCoord.xy, depth);

                  // 射线原点即眼睛位置
                  vec3 rayOrigin = vec3(0.);
                  vec3 rayDirection = normalize(pointEC - rayOrigin);

                  IntersectInfo intersectInfo = isIntersect(box, rayOrigin, rayDirection, pointEC);
                  if (intersectInfo.hit) {
                    vec3 color = vec3(1.0, 0.0, 0.0);
                    // vec3 lightDirEC = czm_lightDirectionEC;
                    out_FragColor = vec4(mix(out_FragColor.rgb, color, 0.5), 1.);
                  }

                }
          `,
            });
            scene.postProcessStages.add(stage);
          }, 5000);
        };

        viewer.terrainProvider.requestTileGeometry = (x, y, level, request) =>
          new Promise((resolve, reject) => {
            loadStage();
            originRequest(x, y, level, request).then((geometry) => {
              resolve(geometry);
            }, reject);
          });
      };

      processTerrainProvider();

      // 地形变化时depthTexture会暂时取不到值
      scene.globe.terrainProviderChanged.addEventListener(() => {
        processTerrainProvider();
      });
    </script>
  </body>
</html>
